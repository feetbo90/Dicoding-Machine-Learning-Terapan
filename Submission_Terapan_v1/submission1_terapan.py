# -*- coding: utf-8 -*-
"""Submission1_Terapan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GGMnW7GoLtnLtkYQOx7mO_qN6DDm_8x1

Problem Statements : Fitur apa yang paling berpengaruh terhadap pengunduran diri pelanggan terhadap kartu kredit

Nama : Muhammad Iqbal Pradipta

**Menghubungkan Google Drive**

Pada langkah pertama menghubungkan Google Drive ke lingkungan Google Colab untuk mengakses dataset yang diperlukan.
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Menentukan path file**

Menentukan path atau lokasi file yang akan diakses di Google Drive ketika menggunakan Google Colab
"""

base_path = '/content/drive/My Drive/ColabNotebooks/dicoding_ai/machine_learning_terapan/customer_cc.csv'

"""**Import Package**

Import package untuk proses visualisasi data dan development model
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
# %matplotlib inline
sns.set_style('darkgrid')

from sklearn.preprocessing import LabelEncoder

"""**Baca File .csv**

Membaca file csv agar menyesuaikan ke pandas Dataframe
"""

credit_card = pd.read_csv(base_path)
credit_card

"""**Melihat Jumlah Baris dan Jumlah Kolom di dataset credit_card**"""

rows, cols = credit_card.shape
print(f"Jumlah baris: {rows}")
print(f"Jumlah kolom: {cols}")

"""**Melihat jumlah nilai null di setiap kolom**"""

null_values = credit_card.isnull().sum()
print(null_values)

"""**Mengubah nama kolom**

Ada 2 kolom yang terlalu panjang sehingga diubah agar tidak terlalu panjang
"""

credit_card.rename(columns={
    'Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1': 'Naive_Bayes_Classifier_1_mon1',
    'Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2': 'Naive_Bayes_Classifier_2_mon2'
}, inplace=True)

# Menampilkan kolom setelah diubah namanya
print("Kolom setelah diubah namanya:", credit_card.columns.tolist())

credit_card.info()

credit_card

credit_card.describe()

"""**Boxplot**

Dari boxplot ini menunjukkan bahwa mayoritas pelanggan berada dalam rentang usia 40-52 tahun, dengan beberapa outliers yang usianya di atas 70 tahun
"""

# Membuat boxplot untuk fitur 'Customer_Age' dengan warna khusus untuk melihat outliers
box = plt.boxplot(credit_card['Customer_Age'], patch_artist=True)

for box_element in box['boxes']:
    box_element.set(facecolor='lightblue')

for median_element in box['medians']:
    median_element.set(color='red', linewidth=2)

plt.title('Boxplot of Customer Age')
plt.ylabel('Age')

plt.show()

"""**Menampilkan kolom mana yang bersifat kategorikal**

Kode ini berfungsi untuk mengidentifikasi kolom mana saja yang bersifat kategorikal dalam dataset credit_card, yang sering kali diperlukan untuk tahap pre-processing seperti encoding (misalnya dengan Label Encoding) sebelum digunakan dalam model machine learning.
"""

categorical_features = credit_card.select_dtypes(include=['object']).columns.tolist()

# Menampilkan array yang berisi nama-nama kolom bertipe object
print(categorical_features)

"""Kode ini digunakan untuk memahami distribusi data pada kolom kategorikal yang lebih tepatnya kolom Attrition_Flag dalam dataset. Ini memberikan informasi mengenai seberapa sering masing-masing kategori muncul serta kontribusi persentasenya terhadap keseluruhan data."""

feature = categorical_features[0]
count = credit_card[feature].value_counts()
percent = 100*credit_card[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)

"""**Menghitung Frekuensi dari Kategori Attrition_Flag**"""

# Hitung frekuensi dari setiap kategori
counts = credit_card[feature].value_counts()

plt.bar(counts.index, counts.values, color=plt.cm.Blues(range(len(counts))))

plt.xlabel(feature)
plt.ylabel('Count')
plt.title(f'Count of {feature}')

plt.xticks()
plt.tight_layout()
plt.show()

"""Kode dibawah ini untuk membuat subplot per kategori kolom Marital_Status dengan kolom Gender."""

# Menggunakan plt.subplots() untuk membuat subplot per kategori
unique_categories = credit_card[categorical_features[3]].unique()
fig, axes = plt.subplots(1, len(unique_categories), figsize=(15, 5), sharey=True)

for i, category in enumerate(unique_categories):
    subset = credit_card[credit_card[categorical_features[3]] == category]

    counts = subset[categorical_features[1]].value_counts()

    axes[i].bar(counts.index, counts.values, color='skyblue')
    axes[i].set_title(f'{categorical_features[3]}: {category}')
    axes[i].set_xlabel(categorical_features[1])

axes[0].set_ylabel('Count')


plt.tight_layout()
plt.show()

"""**Penjelasan Kode**

Kode ini memvisualisasikan distribusi pelanggan yang ditandai oleh kolom Attrition_Flag berdasarkan kombinasi Gender dan Marital_Status.
Grafik ini berguna untuk melihat pola apakah ada hubungan antara gender, status pernikahan, dan kecenderungan pelanggan untuk berhenti menggunakan layanan (churn).

**Interpretasi Bisnis:**

**1. Pelanggan Existing vs Attrited Berdasarkan Gender dan Status Pernikahan:**

* Baik pada pria maupun wanita, pelanggan yang sudah menikah tampaknya memiliki tingkat churn (attrited) yang lebih rendah dibandingkan dengan pelanggan yang masih single atau tidak diketahui status pernikahannya.
* Pada kategori pelanggan "Married" (baik pria maupun wanita), terdapat jumlah pelanggan existing yang sangat tinggi dibandingkan dengan pelanggan yang attrited.
* Pelanggan dengan status "Single" juga menunjukkan pola serupa, meskipun dengan jumlah yang sedikit lebih rendah.

**2. Peran Status Pernikahan dalam Pelanggan Attrited:**

* Pelanggan dengan status pernikahan "Unknown" dan "Divorced" cenderung memiliki tingkat churn yang lebih tinggi atau hampir sama dengan existing customer dalam kategori tertentu.
* Ini bisa menunjukkan bahwa status pernikahan mempengaruhi stabilitas hubungan pelanggan dengan perusahaan, di mana pelanggan yang menikah cenderung lebih setia.

**3. Peluang Segmentasi Pelanggan:**

* Pelanggan yang sudah menikah tampaknya lebih loyal dibandingkan dengan kategori lainnya. Hal ini bisa digunakan oleh perusahaan untuk menawarkan produk yang lebih relevan bagi segmen ini.

"""

# Menggunakan plt.subplots() untuk membuat subplot per kombinasi Gender dan Marital_Status
unique_genders = credit_card['Gender'].unique()
unique_marital_status = credit_card['Marital_Status'].unique()

fig, axes = plt.subplots(len(unique_genders), len(unique_marital_status), figsize=(15, 8), sharey=True)

for i, gender in enumerate(unique_genders):
    for j, marital_status in enumerate(unique_marital_status):
        subset = credit_card[(credit_card['Gender'] == gender) & (credit_card['Marital_Status'] == marital_status)]

        counts = subset['Attrition_Flag'].value_counts()

        axes[i, j].bar(counts.index, counts.values, color='skyblue')
        axes[i, j].set_title(f'Gender: {gender}\nMarital Status: {marital_status}')
        axes[i, j].set_xlabel('Attrition_Flag')

        if j == 0:
            axes[i, j].set_ylabel('Count')

plt.tight_layout()
# plt.title('Customer Behavior Analysis Based on Gender, Marital Status, and Customer Attribute Flags')

plt.show()

"""**Penjelasn Kode**

Kode ini untuk menunjukkan jumlah pelanggan dalam setiap kategori pendapatan (Income_Category) yang dibagi berdasarkan apakah pelanggan tersebut masih ada atau sudah berhenti (Existing Customer atau Attrited Customer)

**Interpretasi Bisnis:**

**1. Distribusi Pelanggan Existing:**

* Pelanggan dengan pendapatan kurang dari 40K memiliki jumlah paling tinggi dalam kategori existing customer, jauh melebihi kategori pendapatan lainnya. Hal ini menunjukkan bahwa perusahaan memiliki basis pelanggan yang kuat di segmen berpenghasilan rendah.
Kategori pendapatan 40K s/d 60K juga memiliki jumlah pelanggan existing yang cukup besar, meskipun lebih sedikit dibandingkan kategori berpenghasilan rendah.
* Pelanggan existing di kategori pendapatan 120K+ dan 80K s/d 120K relatif sedikit, menandakan bahwa perusahaan tidak banyak menarik pelanggan di segmen pendapatan tinggi.

**2. Distribusi Pelanggan Attrited (Churned):**

* Pelanggan attrited juga cenderung lebih banyak di kategori pendapatan kurang dari 40K dan Unknown, tetapi dalam jumlah yang lebih kecil dibandingkan existing customer.
* Kategori pendapatan yang lebih tinggi, seperti 120K+ dan 80K s/d 120K, memiliki jumlah churn yang sangat rendah. Ini mungkin menunjukkan bahwa pelanggan berpenghasilan tinggi cenderung lebih stabil atau perusahaan lebih jarang menjangkau segmen ini.

**3. Peluang dan Tantangan:**

* Peluang di Segmen Berpenghasilan Rendah: Basis pelanggan terbesar perusahaan berada di segmen berpenghasilan rendah. Perusahaan dapat terus fokus di segmen ini dengan produk yang terjangkau dan program loyalitas yang kuat.
* Tantangan di Segmen Berpenghasilan Tinggi: Perusahaan memiliki basis pelanggan yang sangat kecil di segmen pendapatan tinggi, baik untuk existing maupun attrited customer. Ada peluang untuk memperluas penetrasi di pasar ini dengan penawaran produk yang lebih premium dan layanan yang disesuaikan.
* Kategori "Unknown": Sejumlah pelanggan di kategori "Unknown" menandakan kurangnya informasi pendapatan pelanggan. Mengidentifikasi pendapatan ini dapat memberikan insight yang lebih baik untuk strategi retensi dan akuisisi pelanggan.
"""

plt.figure(figsize=(10,5))

income_attrition_counts = credit_card.groupby(['Income_Category', 'Attrition_Flag']).size().unstack()

x = np.arange(len(income_attrition_counts))

width = 0.35

plt.bar(x - width/2, income_attrition_counts['Attrited Customer'], width, label='Attrited Customer', color='lightblue')
plt.bar(x + width/2, income_attrition_counts['Existing Customer'], width, label='Existing Customer', color='darkblue')

plt.xlabel('Income Category')
plt.ylabel('Count')
plt.title('Count of Customers by Income Category and Attrition Flag')

plt.xticks(x, income_attrition_counts.index)

plt.legend()

plt.tight_layout()
plt.show()

"""**Churn vs Non-Churn berdasarkan Kategori Kartu**

Grafik ini memberikan visualisasi yang jelas mengenai jumlah pelanggan yang berhenti (churn) dibandingkan dengan pelanggan yang masih aktif (non-churn) berdasarkan kategori kartu.
"""

# Memisahkan data churn dan non-churn
churn_data = credit_card[credit_card['Attrition_Flag'] == 'Attrited Customer']
non_churn_data = credit_card[credit_card['Attrition_Flag'] == 'Existing Customer']

# Menghitung jumlah setiap kategori kartu untuk churn dan non-churn
churn_counts = churn_data['Card_Category'].value_counts()
non_churn_counts = non_churn_data['Card_Category'].value_counts()

# Membuat plot bar untuk churn dan non-churn secara berdampingan
fig, ax = plt.subplots(figsize=(10, 6))

# Menambahkan bar untuk churn dan non-churn
churn_counts.plot(kind='bar', color='salmon', ax=ax, position=0, width=0.4, label='Churn')
non_churn_counts.plot(kind='bar', color='skyblue', ax=ax, position=1, width=0.4, label='Non-Churn')

# Menambahkan judul dan label
ax.set_title('Churn vs Non-Churn berdasarkan Kategori Kartu', fontsize=14)
ax.set_xlabel('Card Category')
ax.set_ylabel('Count')
ax.legend()

plt.xticks(rotation=360)
plt.tight_layout()
plt.show()

"""**Histogram and KDE of Months on Book**

Plot dibawah ini menunjukkan distribusi lama waktu pelanggan (dalam bulan) telah terdaftar di bank. Histogram memperlihatkan distribusi data asli, sementara KDE menambahkan kurva halus yang memperkirakan distribusi probabilitas dari data tersebut. Kombinasi histogram dan KDE ini berguna untuk memahami bagaimana data terdistribusi secara lebih rinci.


**Sebaran Data**

* Grafik menunjukkan distribusi yang sedikit miring ke kanan. Artinya, terdapat lebih sedikit nasabah yang telah menjadi pelanggan lebih lama, dan sebagian besar nasabah memiliki waktu berlangganan kurang dari 50 bulan.

* Ada beberapa nasabah yang memiliki waktu berlangganan lebih lama (lebih dari 50 bulan), tetapi jumlahnya sangat kecil dibandingkan dengan kelompok yang berada di sekitar 36 bulan.

**Interpretasi Bisnis**

* Bank mungkin ingin fokus pada nasabah dengan waktu berlangganan di sekitar 36 bulan karena ini adalah kelompok yang paling besar. Ini bisa menjadi target potensial untuk meningkatkan keterlibatan atau menawarkan produk baru.

* Nasabah yang sudah berlangganan lebih lama (lebih dari 50 bulan) adalah kelompok kecil yang mungkin membutuhkan perhatian khusus, terutama jika ada kekhawatiran tentang churn atau loyalitas nasabah.
"""

from scipy.stats import gaussian_kde

plt.figure(figsize=(10,5))

# Membuat histogram untuk kolom 'Months_on_book'
# Months_on_book: Lama waktu (dalam bulan) pelanggan telah terdaftar (Integer).

data = credit_card['Months_on_book']
plt.hist(data, bins=30, color='lightblue', edgecolor='black', alpha=0.7, density=True, label='Histogram')

# Menambahkan KDE (Kernel Density Estimation)
kde = gaussian_kde(data)
x_vals = np.linspace(data.min(), data.max(), 100)
plt.plot(x_vals, kde(x_vals), color='red', label='KDE')

# Menambahkan label dan judul
plt.xlabel('Months on Book')
plt.ylabel('Density')
plt.title('Histogram and KDE of Months on Book')

# Menambahkan legenda
plt.legend()

# Menampilkan plot
plt.tight_layout()
plt.show()

"""**Count of Customers by Total Relationship Count and Attrition Flag**

**Interpretasi Bisnis**
* Keterkaitan Antara Jumlah Produk dan Churn: Grafik menunjukkan bahwa pelanggan dengan lebih banyak produk (Total Relationship Count lebih tinggi) cenderung untuk tetap menggunakan layanan bank. Ini menunjukkan bahwa memperluas hubungan dengan pelanggan bisa menjadi strategi untuk mengurangi churn.
* Fokus pada Pelanggan dengan Hubungan Rendah: Pelanggan dengan 1 atau 2 hubungan memiliki proporsi yang lebih tinggi untuk berhenti. Bank mungkin ingin merancang strategi untuk meningkatkan keterlibatan mereka atau menawarkan produk tambahan untuk mengurangi risiko churn.
"""

# Menentukan ukuran figure
plt.figure(figsize=(10, 5))

# Menghitung frekuensi untuk setiap kombinasi Total_Relationship_Count dan Attrition_Flag
counts = credit_card.groupby(['Total_Relationship_Count', 'Attrition_Flag']).size().unstack(fill_value=0)

x = np.arange(len(counts))

width = 0.35

plt.bar(x - width/2, counts['Attrited Customer'], width, label='Attrited Customer', color='lightblue')
plt.bar(x + width/2, counts['Existing Customer'], width, label='Existing Customer', color='darkblue')

plt.xlabel('Total Relationship Count')
plt.ylabel('Count')
plt.title('Count of Customers by Total Relationship Count and Attrition Flag')

plt.xticks(x, counts.index, rotation=0)

plt.legend()

plt.tight_layout()
plt.show()

"""**Count of Customers by Months Inactive and Contacts Count (12 months)**
- Months_Inactive_12_mon: Jumlah bulan pelanggan tidak aktif dalam 12 bulan terakhir (Integer).
- Contacts_Count_12_mon: Jumlah kontak yang dilakukan pelanggan dengan penyedia dalam 12 bulan terakhir (Integer).
- Menghitung frekuensi untuk setiap kombinasi Months_Inactive_12_mon dan Contacts_Count_12_mon
"""

# Contacts_Count_12_mon VS. Months_Inactive_12_mon
plt.figure(figsize=(10, 5))

# Months_Inactive_12_mon: Jumlah bulan pelanggan tidak aktif dalam 12 bulan terakhir (Integer).
# Contacts_Count_12_mon: Jumlah kontak yang dilakukan pelanggan dengan penyedia dalam 12 bulan terakhir (Integer).
# Menghitung frekuensi untuk setiap kombinasi Months_Inactive_12_mon dan Contacts_Count_12_mon
counts = credit_card.groupby(['Months_Inactive_12_mon', 'Contacts_Count_12_mon']).size().unstack(fill_value=0)

x = np.arange(len(counts))

width = 0.15

for i, column in enumerate(counts.columns):
    plt.bar(x + (i * width), counts[column], width, label=f'Contacts = {column}', alpha=0.7)

plt.xlabel('Months Inactive (12 months)')
plt.ylabel('Count')
plt.title('Count of Customers by Months Inactive and Contacts Count (12 months)')

plt.xticks(x + width / 2, counts.index)

plt.legend(title='Contacts Count (12 months)')

plt.tight_layout()
plt.show()

"""**Histogram and KDE of Credit Limit**
* Menunjukkan distribusi batas kredit (credit limit) dalam populasi.
* Mayoritas orang memiliki batas kredit yang rendah, terlihat dari konsentrasi tinggi pada nilai antara 0 hingga sekitar 5000.
* Jumlah orang yang memiliki batas kredit tinggi (di atas 10.000) menurun drastis, dan sangat sedikit orang yang memiliki batas kredit di sekitar 30.000 hingga 35.000.

* Fungsi KDE memberikan estimasi mulus dari distribusi data, sehingga kita dapat melihat tren secara lebih halus.
* Garis ini menegaskan bahwa distribusi cenderung miring ke kanan (right-skewed), dengan sebagian besar data terkonsentrasi di batas kredit yang rendah.
* Ada sedikit kenaikan pada batas kredit sekitar 35.000, yang mungkin menunjukkan adanya beberapa pengguna dengan batas kredit tinggi yang signifikan.
"""

plt.figure(figsize=(10, 5))

# Membuat histogram untuk kolom 'Credit_Limit'
data = credit_card['Credit_Limit']
plt.hist(data, bins=30, color='lightblue', edgecolor='black', alpha=0.7, density=True, label='Histogram')

# Menambahkan KDE (Kernel Density Estimation)
kde = gaussian_kde(data)
x_vals = np.linspace(data.min(), data.max(), 100)
plt.plot(x_vals, kde(x_vals), color='red', label='KDE', linewidth=2)

# Menambahkan label dan judul
plt.xlabel('Credit Limit')
plt.ylabel('Density')
plt.title('Histogram and KDE of Credit Limit')

# Menambahkan legenda
plt.legend()

# Menampilkan plot
plt.tight_layout()
plt.show()

"""Dari perspektif bisnis, grafik bisa mengindikasikan stabilitas dalam penggunaan kartu kredit dari satu kuartal ke kuartal berikutnya. Jika mengharapkan peningkatan penggunaan kartu kredit di Q1 (misalnya, setelah periode belanja Q4 yang tinggi), hasil ini mungkin menunjukkan perlunya penyesuaian strategi promosi atau marketing untuk mendorong lebih banyak transaksi di awal tahun."""

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(20, 7))

# Histogram untuk perubahan total jumlah dari Q4 ke Q1
sns.histplot(x='Total_Amt_Chng_Q4_Q1', data=credit_card, kde=True, ax=ax[0], color='lightblue', bins=30)
ax[0].set_title('Total Amount Changed from Q4 to Q1')
ax[0].set_xlabel('Total Amount Change')
ax[0].set_ylabel('Density')

# Histogram untuk perubahan total hitungan dari Q4 ke Q1
sns.histplot(x='Total_Ct_Chng_Q4_Q1', data=credit_card, kde=True, ax=ax[1], color='lightgreen', bins=30)
ax[1].set_title('Total Count Changed from Q4 to Q1')
ax[1].set_xlabel('Total Count Change')
ax[1].set_ylabel('Density')

# Menampilkan plot
plt.tight_layout()
plt.show()

"""**Segmentation of Customer Behavior**

- **Nasabah Berfrekuensi Tinggi, Nilai Rendah**: Kelompok di kanan menunjukkan nasabah yang aktif bertransaksi tetapi dengan nilai transaksi yang kecil. Mereka mungkin adalah pengguna yang melakukan pembelian rutin atau harian, seperti belanja sehari-hari.
- **Nasabah Jarang Bertransaksi, Nilai Tinggi**: Kelompok di kiri menunjukkan nasabah yang jarang bertransaksi tetapi ketika mereka melakukannya, nilai transaksi mereka tinggi. Mereka mungkin pengguna yang membeli barang-barang mahal secara berkala.
"""

# Total_Trans_Amt: Total jumlah transaksi selama periode tertentu (Integer).
# Total_Trans_Ct: Jumlah total transaksi selama periode tertentu (Integer).
plt.figure(figsize=(10, 5))

# Membuat scatter plot untuk Total Transaction Amount vs Total Transaction Count
sns.scatterplot(x='Total_Trans_Amt', y='Total_Trans_Ct', data=credit_card, color='blue', alpha=0.6)

plt.title('Scatter Plot of Total Transaction Amount vs Total Transaction Count')
plt.xlabel('Total Transaction Amount')
plt.ylabel('Total Transaction Count')

# Menampilkan plot
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Histogram of Average Utilization Ratio**

**Distribusi Data**
- Sebagian besar pelanggan memiliki Average Utilization Ratio yang sangat rendah, terlihat dari puncak yang sangat tinggi di dekat nilai 0.
- Ini berarti bahwa banyak pelanggan yang menggunakan hanya sebagian kecil dari batas kredit mereka.
- Setelah itu, frekuensi menurun secara eksponensial seiring dengan meningkatnya nilai rasio. Hanya sedikit pelanggan yang memanfaatkan rasio kredit yang mendekati 1 (menggunakan kredit hampir sepenuhnya).

**KDE (Kernel Density Estimation)**
- Garis ungu halus di atas histogram adalah KDE, yang menunjukkan estimasi kerapatan probabilitas dari data ini.
- KDE menghaluskan distribusi frekuensi, memberikan pandangan yang lebih jelas tentang pola distribusi dari data.
"""

# Avg_Utilization_Ratio: Rata-rata rasio pemanfaatan kredit pelanggan (Integer).
plt.figure(figsize=(10, 5))

# Membuat histogram untuk Avg Utilization Ratio dengan KDE
sns.histplot(x='Avg_Utilization_Ratio', data=credit_card, kde=True, color='purple', bins=30)

# Menambahkan judul dan label sumbu
plt.title('Histogram of Average Utilization Ratio')
plt.xlabel('Average Utilization Ratio')
plt.ylabel('Frequency')

# Menampilkan plot
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Label Encoder** adalah alat yang digunakan untuk mengonversi data kategorikal ke dalam format numerik."""

le=LabelEncoder()
for column in categorical_features:
    credit_card[column]=le.fit_transform(credit_card[column])
credit_card.head()

"""Melihat Keterhubungan antara variabel dengan variabel Attrition_Flag"""

for col in categorical_features:
  sns.catplot(x=col, y="Attrition_Flag", kind="bar", dodge=False, height = 4, aspect = 3,  data=credit_card, palette="Set3")
  plt.title("Rata-rata 'Attrition_Flag' Relatif terhadap - {}".format(col))

"""**Menampilkan kolom yang tidak berjenis 'object'**"""

# Menampilkan kolom yang tidak berjenis 'object'
non_object_columns = credit_card.select_dtypes(exclude=['object']).columns

numeric_columns = non_object_columns.tolist()

print("Kolom selain 'object':", numeric_columns)

"""**Multivariat**

Berikut adalah hubungan antara Attrition_Flag (indikator apakah pelanggan meninggalkan atau tidak) dengan beberapa fitur lain:

**Total_Trans_Ct (Jumlah Total Transaksi):**

Korelasi antara Attrition_Flag dan Total_Trans_Ct adalah 0.4, yang berarti ada hubungan positif sedang. Ini menunjukkan bahwa semakin banyak transaksi yang dilakukan pelanggan, semakin kecil kemungkinan mereka untuk churn. Pelanggan yang lebih aktif cenderung bertahan.

**Total_Trans_Amt (Jumlah Total dari Semua Transaksi):**

Korelasi dengan Attrition_Flag adalah 0.2, yang menunjukkan hubungan positif. Pelanggan yang menghabiskan lebih banyak uang melalui transaksi cenderung tidak meninggalkan layanan.


**Total_Relationship_Count (Jumlah Hubungan Total dengan Perusahaan):**

Korelasi 0.2 dengan Attrition_Flag menunjukkan bahwa semakin banyak interaksi atau hubungan yang dimiliki pelanggan dengan perusahaan (misalnya melalui layanan, produk, atau kontak lainnya), semakin kecil kemungkinan mereka untuk churn.

**Avg_Utilization_Ratio (Rata-rata Penggunaan Kredit):**

Korelasi dengan Attrition_Flag adalah 0.2, yang berarti ada hubungan positif kecil. Pelanggan dengan rasio penggunaan kredit yang lebih tinggi (menggunakan lebih banyak dari kredit mereka yang tersedia) cenderung lebih mungkin untuk churn.

**Total_Revolving_Bal (Total Saldo Berputar):**

Korelasi positif 0.3 dengan Attrition_Flag, meskipun kecil. Ini menunjukkan sedikit kecenderungan bahwa pelanggan dengan saldo berputar lebih besar mungkin lebih mungkin untuk churn.

**Months_Inactive_12_mon (Bulan Tidak Aktif dalam 12 Bulan Terakhir):**

Korelasi kecil negatif -0.2 menunjukkan bahwa pelanggan yang lebih lama tidak aktif dalam 12 bulan terakhir lebih cenderung untuk churn.

**Contacts_Count_12_mon (Jumlah Kontak dengan Perusahaan dalam 12 Bulan Terakhir):**

Korelasi kecil negatif -0.2, menunjukkan bahwa semakin banyak kontak dengan perusahaan, semakin kecil kemungkinan pelanggan akan churn. Namun, pengaruhnya sangat kecil.
"""

# plt.figure(figsize=(10, 8))
# correlation_matrix = credit_card[numeric_columns].corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
# sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
# plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)
plt.figure(figsize=(20,7))
correlation=credit_card.corr()
sns.heatmap(correlation,vmin=None,
    vmax=0.8,
    cmap='coolwarm',
    annot=True,
    fmt='.1f',
    linecolor='white',
    cbar=True);

"""Kode dibawah ini mempersiapkan data untuk proses pemodelan dengan menghapus beberapa kolom yang tidak diperlukan, memisahkan variabel target dari fitur, melakukan standarisasi fitur numerik, dan membagi dataset menjadi data pelatihan dan pengujian."""

from sklearn.model_selection import train_test_split

#  menghapus banyak kolom menggunakan drop
credit_card_drop = credit_card.drop(['Months_on_book', 'Credit_Limit', 'Avg_Open_To_Buy', 'Total_Amt_Chng_Q4_Q1', 'Dependent_count', 'Customer_Age', 'Gender', 'Education_Level', 'Marital_Status', 'Income_Category', 'Card_Category'], axis=1)
y = credit_card['Attrition_Flag']
X = credit_card_drop.drop('Attrition_Flag', axis=1)

# Membagi dataset menjadi data training dan testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
X

from sklearn.metrics import confusion_matrix, classification_report, accuracy_score
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import mean_squared_error

# Latih model Logistic Regression
logreg = LogisticRegression()
logreg.fit(X_train, y_train)

# Prediksi hasil pada test data
y_pred = logreg.predict(X_test)

# Prediksi pada data training
y_train_pred = logreg.predict(X_train)

# Evaluasi model menggunakan confusion matrix
cm = confusion_matrix(y_test, y_pred)

# Plot confusion matrix
plt.figure(figsize=(5, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

# Hitung akurasi pada data training
training_accuracy = accuracy_score(y_train, y_train_pred)

print(f'Akurasi pada data training: {training_accuracy}')
# Laporan klasifikasi
print("Accuracy Score:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

rf_clf = RandomForestClassifier(random_state=42)
rf_clf.fit(X_train, y_train)
y_pred_rf = rf_clf.predict(X_test)

rf_acc = accuracy_score(y_test, y_pred_rf)
print("\nRandom Forest:")

# Prediksi pada data training
y_train_pred = rf_clf.predict(X_train)
# Hitung akurasi pada data training
training_accuracy = accuracy_score(y_train, y_train_pred)

print(f'Akurasi pada data training: {training_accuracy}')
print(f"Accuracy Score: {rf_acc}")

print("Classification Report:\n", classification_report(y_test, y_pred_rf))