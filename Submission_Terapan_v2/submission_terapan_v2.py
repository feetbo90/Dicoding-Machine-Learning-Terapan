# -*- coding: utf-8 -*-
"""Submission_Terapan_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LsLYebKAOuJjuOigIox3hTW1e8BvB_sJ

Problem Statements : Movie Recommendation

Nama : Muhammad Iqbal Pradipta

# **Install Package**
"""

!pip install scikit-surprise

"""# **Import Package**

Import package untuk proses visualisasi data dan development model
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
# %matplotlib inline
sns.set_style('darkgrid')
import scipy.stats as stats
import json
import ast
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""# **Load and Check Dataset**

**Menghubungkan Google Drive**

Pada langkah pertama menghubungkan Google Drive ke lingkungan Google Colab untuk mengakses dataset yang diperlukan.
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Menentukan path file**

Menentukan path atau lokasi file yang akan diakses di Google Drive ketika menggunakan Google Colab
"""

movies = '/content/drive/My Drive/ColabNotebooks/dicoding_ai/machine_learning_terapan/tmdb_movies.csv'
credits = '/content/drive/My Drive/ColabNotebooks/dicoding_ai/machine_learning_terapan/tmdb_credits.csv'
ratings_small = '/content/drive/My Drive/ColabNotebooks/dicoding_ai/machine_learning_terapan/ratings_small.csv'

"""**Baca File .csv**

Membaca file csv agar menyesuaikan ke pandas Dataframe
"""

# Load the datasets
movies_df = pd.read_csv(movies)
credits_df = pd.read_csv(credits)
ratings_small_df = pd.read_csv(ratings_small)

# Print the DataFrames
print("Data Movies")
movies_df.head()

"""**Menampilkan 5 data dari dataset credits**"""

print("\nData Credits")
credits_df.head()

"""**Menampilkan 5 data dari dataset rating small**"""

ratings_small_df.head()

"""**Melihat info dari dataset movies**"""

movies_df.info()

"""**Melihat info dari dataset credits**"""

credits_df.info()

"""**Melihat info dari dataset ratings**"""

ratings_small_df.info()

"""**Melihat describe dari dataset movies**"""

movies_df.describe()

"""**Melihat describe dari dataset credits**"""

credits_df.describe()

"""**Melihat describe dari dataset ratings**"""

ratings_small_df.describe()

"""**Melihat Jumlah Baris dan Jumlah Kolom di dataset movies**"""

rows, cols = movies_df.shape
print(f"Jumlah baris dataset movies: {rows}")
print(f"Jumlah kolom movies: {cols}")

"""**Melihat Jumlah Baris dan Jumlah Kolom di dataset credits**"""

rows, cols = credits_df.shape
print(f"Jumlah baris dataset credits: {rows}")
print(f"Jumlah kolom credits: {cols}")

"""**Melihat Jumlah Baris dan Jumlah Kolom di dataset ratings**"""

rows, cols = ratings_small_df.shape
print(f"Jumlah baris dataset ratings_small: {rows}")
print(f"Jumlah kolom ratings_small: {cols}")

"""**Melihat jumlah nilai null di dataset movies**"""

null_values_movies = movies_df.isnull().sum()
null_values_movies

"""**Melihat jumlah nilai null di dataset credits**"""

null_values_credits = credits_df.isnull().sum()
null_values_credits

"""**Melihat jumlah nilai null di dataset ratings**"""

null_values_ratings_small = ratings_small_df.isnull().sum()
null_values_ratings_small

"""# **Data Preprocessing**

**Mengisi nilai yang null**
"""

movies_df['runtime'].head()

"""**Mengisi nilai null fitur runtime dengan mean**"""

runtime_mean = movies_df['runtime'].mean()
movies_df['runtime'] = movies_df['runtime'].fillna(runtime_mean)
movies_df['tagline'] = movies_df['tagline'].fillna(object())
movies_df['homepage'] = movies_df['homepage'].fillna(object())
movies_df['overview'] = movies_df['tagline'].fillna(object())
movies_df['release_date'] = movies_df['release_date'].fillna(object())

"""**Cek kembali apakah masih ada fitur yang null**"""

null_values_movies = movies_df.isnull().sum()
null_values_movies

"""**Melihat top 10 Film Terbaik**"""

# Langkah 1: Tentukan rata-rata dari seluruh film dan batas minimum jumlah vote
C = movies_df['vote_average'].mean()  # Rata-rata keseluruhan dari rating
m = movies_df['vote_count'].quantile(0.90)  # 90th percentile dari jumlah vote (film yang berada di top 10%)

# Langkah 2: Filter hanya film yang memiliki jumlah vote di atas m
qualified_movies = movies_df[movies_df['vote_count'] >= m]

# Langkah 3: Menghitung Weighted Rating menggunakan formula WR
def weighted_rating(x, m=m, C=C):
    v = x['vote_count']
    R = x['vote_average']
    # Menghitung weighted rating berdasarkan formula WR
    return (v / (v + m) * R) + (m / (v + m) * C)

qualified_movies = movies_df[movies_df['vote_count'] >= m].copy()

# Menghitung Weighted Rating dan menetapkannya pada kolom 'score'
qualified_movies['score'] = qualified_movies.apply(weighted_rating, axis=1)

# Melanjutkan proses sorting dan pengambilan 10 film terbaik
top_movies = qualified_movies.sort_values('score', ascending=False)

# Ambil 10 film terbaik
top_10_movies = top_movies[['title', 'vote_average', 'vote_count', 'score']].head(10)


# Menampilkan 10 film terbaik
top_10_movies

"""**Cek tipe data di kolom 'overview'**"""

overview_types = movies_df['overview'].apply(type)
print(overview_types.value_counts())

# Mengganti nilai yang bertipe 'object' dengan string kosong
movies_df['overview'] = movies_df['overview'].apply(lambda x: x if isinstance(x, str) else '')

# Verifikasi tipe data setelah perubahan
overview_types = movies_df['overview'].apply(type)
overview_types.value_counts()

"""**clean_text digunakan untuk membersihkan teks dan menghapus baris kosong**

"""

# Fungsi untuk membersihkan teks
def clean_text(text):
    if isinstance(text, str):
        # Mengubah teks menjadi huruf kecil
        text = text.lower()
        # Menghapus angka dan karakter khusus
        text = re.sub(r'[^a-z\s]', '', text)
    return text

# Terapkan fungsi bersih pada kolom overview
movies_df['cleaned_overview'] = movies_df['overview'].apply(clean_text)

# Menghapus baris dengan cleaned_overview kosong
movies_df = movies_df[movies_df['cleaned_overview'].str.strip() != '']

movies_df['cleaned_overview'].head()

"""**Mengurutkan dan menampilkan dataFrame berdasarkan kolom 'popularity'**"""

top_popular_movies = movies_df.sort_values('popularity', ascending=False)

top_10_popular_movies = top_popular_movies[['title', 'popularity', 'vote_average', 'vote_count',
                                            'production_companies', 'production_countries', 'release_date']].head(10)

# Menampilkan tabel film dengan popularity terbanyak
top_10_popular_movies

"""**Membuat histogram 10 Film berdasarkan popularitas**"""

# Membuat plot bar dengan nama film di sumbu X dan popularitas di sumbu Y
plt.figure(figsize=(12,6))
plt.bar(top_10_popular_movies['title'], top_10_popular_movies['popularity'], color='skyblue')

# Menambahkan judul dan label
plt.title('Top 10 Film Berdasarkan Popularitas', fontsize=16)
plt.xlabel('Film', fontsize=14)
plt.ylabel('Popularity', fontsize=14)

# Memutar label nama film di sumbu X agar lebih mudah dibaca
plt.xticks(rotation=45, ha='right')

# Menampilkan plot
plt.tight_layout()
plt.show()

"""**Fungsi extract_production_countries bertujuan untuk mengubah string JSON yang terdapat dalam kolom production_countries menjadi list Python yang lebih mudah dipahami.**"""

def extract_production_countries(countries):
    try:
        countries_list = json.loads(countries)
        return ', '.join([country['name'] for country in countries_list])
    except (json.JSONDecodeError, TypeError):
        return ''

movies_df['production_countries_full'] = movies_df['production_countries'].apply(extract_production_countries)

movies_df[['title', 'production_countries_full']].head(10)

"""**Fungsi extract_production_companies bertujuan untuk mengubah string JSON yang terdapat dalam kolom production_companies menjadi list Python yang lebih mudah dipahami.**"""

def extract_production_companies(companies):
    try:
        companies_list = json.loads(companies)
        return ', '.join([company['name'] for company in companies_list])
    except (json.JSONDecodeError, TypeError):
        return ''

movies_df['production_companies_full'] = movies_df['production_companies'].apply(extract_production_companies)

movies_df[['title', 'production_companies_full']].head(10)

"""**Fungsi extract_names digunakan untuk mengekstrak nama-nama aktor dari string JSON yang terdapat dalam kolom cast di DataFrame credits_df.**"""

def extract_names(cast_json):
    cast_list = ast.literal_eval(cast_json)
    names = [cast['name'] for cast in cast_list]
    return ', '.join(names)

credits_df['cast_names'] = credits_df['cast'].apply(extract_names)

"""**Melihat apakah cast_names sudah ter create dan non null**"""

credits_df.info()

"""**Fungsi convert_genres digunakan untuk mengubah fitur genre JSON string menjadi dictionaries**"""

def convert_genres(json_str):
    try:
        # Parsing string JSON menjadi list of dictionaries
        return json.loads(json_str)
    except ValueError:
        # Jika parsing gagal, kembalikan list kosong
        return []

# Fungsi untuk mengekstrak nama genre dari list of dictionaries
def extract_genre_names(genres):
    # Pastikan data adalah list sebelum melakukan ekstraksi
    if isinstance(genres, list):
        return [genre['name'] for genre in genres if 'name' in genre]
    return []  # Kembalikan list kosong jika bukan list

# Menerapkan fungsi di seluruh kolom 'genres'
movies_df['genres_list'] = movies_df['genres'].apply(convert_genres)
movies_df['genre_names'] = movies_df['genres_list'].apply(extract_genre_names)

# Menampilkan hasil akhir
movies_df[['title', 'genre_names', 'genres_list']].head()

"""**Mengekstrak fitur cast dan merged dataset movies dan credits**"""

# Misalkan credits_df dan movies_df adalah DataFrame yang sudah Anda buat

# Pertama, kita perlu mengekstrak nama aktor dari 'cast' dalam credits_df
def extract_cast_names(cast):
    # Pastikan cast bukan NaN atau kosong
    if isinstance(cast, str) and cast != "[]":
        cast_list = eval(cast)  # Mengubah string JSON menjadi list of dictionaries
        return [member['name'] for member in cast_list]  # Ambil nama dari setiap anggota
    return []

# Terapkan fungsi untuk mengekstrak nama cast
credits_df['cast_names'] = credits_df['cast'].apply(extract_cast_names)

# Gabungkan credits_df dan movies_df berdasarkan movie_id dan id
merged_df = pd.merge(movies_df, credits_df[['movie_id', 'crew', 'cast_names']],
                     left_on='id', right_on='movie_id', how='left')

# Tampilkan kolom yang ada di merged_df untuk debugging
print("Kolom di merged_df:", merged_df.columns)

# Pilih kolom yang relevan dari merged_df
final_df = merged_df[['id', 'title', 'keywords', 'budget', 'genre_names',
                       'cleaned_overview', 'popularity',
                       'production_companies_full',
                       'production_countries_full', 'revenue',
                       'status', 'vote_average', 'vote_count',
                       'crew', 'cast_names']]

"""**Menampilkan dataset yang sudah di merged**"""

final_df[['title', 'genre_names', 'cleaned_overview', 'popularity',
                 'production_companies_full', 'production_countries_full',
                 'revenue', 'status', 'vote_average', 'vote_count',
                 ]].head()

"""**Menampilkan informasi dari dataset gabungan credit dan movie**"""

final_df.info()

"""**Fungsi untuk mengambil nama Director dari kolom crew**"""

# Fungsi untuk mengekstrak director dari kolom crew
def extract_director(crew):
    # Pastikan crew bukan NaN atau kosong
    if isinstance(crew, str) and crew != "[]":
        crew_list = eval(crew)  # Mengubah string JSON menjadi list of dictionaries
        # Cari anggota crew yang memiliki job sebagai 'Director'
        for member in crew_list:
            if member['job'] == 'Director':
                return member['name']
    return None

# Menggunakan .loc untuk menghindari SettingWithCopyWarning
final_df.loc[:, 'director'] = final_df['crew'].apply(extract_director)

# Lihat 5 baris pertama untuk memastikan data director telah diekstrak dengan benar
final_df.head()

"""**Menghapus duplikat berdasarkan kolom 'title'**"""

final_df = final_df.drop_duplicates(subset='title', keep='first').reset_index(drop=True)

# Menampilkan DataFrame setelah menghapus duplikat
final_df.head()

"""**Modelling**

**Fungsi untuk mengambil rekomendasi film berdasarkan cleaned_overview**
"""

tfidf = TfidfVectorizer(stop_words='english')

final_df['cleaned_overview'] = final_df['cleaned_overview'].fillna('')
tfidf_matrix = tfidf.fit_transform(final_df['cleaned_overview'])

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

def recommend_movies(title, cosine_sim=cosine_sim):
    idx = pd.Series(final_df.index, index=final_df['title']).drop_duplicates()

    movie_idx = idx[title]

    sim_scores = list(enumerate(cosine_sim[movie_idx]))

    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    sim_scores = sim_scores[1:11]  # 1:11 karena 0 adalah film itu sendiri

    movie_indices = [i[0] for i in sim_scores]

    return final_df[['title', 'genre_names']].iloc[movie_indices]

recommended_movies = recommend_movies('The Dark Knight Rises')
recommended_movies

"""**Mengidentifikasi kesamaan antara satu film dengan yang lain**"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul
cosine_sim_df = pd.DataFrame(cosine_sim, index=final_df['title'], columns=final_df['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap judul
cosine_sim_df.sample(5, axis=1).sample(20, axis=0)

"""**Menampilkan tf-idf beserta langkah-langkah**"""

# 1. Menggunakan TF-IDF Vectorizer pada cleaned_overview
final_df['cleaned_overview'] = final_df['cleaned_overview'].fillna('')  # Mengisi NaN dengan string kosong
tfidf_vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf_vectorizer.fit_transform(final_df['cleaned_overview'])

# 2. Mendapatkan nama fitur (kata-kata)
feature_names = tfidf_vectorizer.get_feature_names_out()

# 3. Menghitung skor TF-IDF rata-rata untuk setiap kata
tfidf_array = tfidf_matrix.toarray()
average_tfidf_scores = tfidf_array.mean(axis=0)

# 4. Membuat DataFrame untuk menyimpan kata dan nilai TF-IDF
tfidf_scores_df = pd.DataFrame({
    'word': feature_names,
    'average_tfidf': average_tfidf_scores
})

# 5. Mengurutkan DataFrame berdasarkan nilai TF-IDF
tfidf_scores_df = tfidf_scores_df.sort_values(by='average_tfidf', ascending=False)

# 6. Menampilkan 10 kata teratas berdasarkan nilai TF-IDF
top_tfidf_words = tfidf_scores_df.head(10)
print(top_tfidf_words)

"""**Cosine Similirity**"""

tfidf = TfidfVectorizer(stop_words='english')
final_df['cleaned_overview'] = final_df['cleaned_overview'].fillna('')
tfidf_matrix = tfidf.fit_transform(final_df['cleaned_overview'])

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

idx = pd.Series(final_df.index, index=final_df['title']).drop_duplicates()
movie_idx = idx["The Dark Knight Rises"]

cosine_sim_dark_knight = cosine_sim[movie_idx]

cosine_sim_df = pd.DataFrame({
    'title': final_df['title'],
    'cosine_similarity': cosine_sim_dark_knight
})
cosine_sim_df = cosine_sim_df.sort_values(by='cosine_similarity', ascending=False).head(11)
print(cosine_sim_df.iloc[1:])

"""**Percobaan rekomendasi film berdarkan director yang sejenis dan menampilkan film apa saja yang dibuat berdasarkan nama director**"""

# Asumsi final_df sudah ada dan memiliki kolom 'director'

# 1. Menggunakan TF-IDF Vectorizer pada kolom director
final_df['director'] = final_df['director'].fillna('')  # Mengisi NaN dengan string kosong
tfidf_director = TfidfVectorizer(stop_words='english')
tfidf_director_matrix = tfidf_director.fit_transform(final_df['director'])

# 2. Menghitung cosine similarity berdasarkan direktur
cosine_sim_director = cosine_similarity(tfidf_director_matrix, tfidf_director_matrix)

# 3. Membuat fungsi rekomendasi berdasarkan direktur
def recommend_movies_by_director(director_name, cosine_sim=cosine_sim_director):
    # Mendapatkan indeks film yang disutradarai oleh direktur yang dipilih
    idx = final_df[final_df['director'].str.contains(director_name, case=False, na=False)].index.tolist()

    if not idx:
        return f"No movies found for director: {director_name}"

    # Mendapatkan skor kesamaan dari semua film dengan film yang dipilih
    sim_scores = []
    for i in idx:
        sim_scores.extend(list(enumerate(cosine_sim[i])))

    # Mengurutkan film berdasarkan skor kesamaan
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Mengambil 10 film paling mirip
    sim_scores = sim_scores[1:11]  # 1:11 karena 0 adalah film itu sendiri

    # Mendapatkan indeks film yang mirip
    movie_indices = [i[0] for i in sim_scores]

    # Mengembalikan judul film yang mirip dan nilai cosine similarity-nya
    result_df = pd.DataFrame({
        'title': final_df['title'].iloc[movie_indices].values,
        'cosine_similarity': [i[1] for i in sim_scores]
    })

    return result_df

# 4. Contoh penggunaan sistem rekomendasi berdasarkan direktur
recommended_movies_director = recommend_movies_by_director('Christopher Nolan')
print(recommended_movies_director)

"""**Mengidentifikasikan kesamaan nilai berdasarkan nama director**"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul
cosine_sim_director = pd.DataFrame(cosine_sim, index=final_df['title'], columns=final_df['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap judul
cosine_sim_director.sample(5, axis=1).sample(20, axis=0)

"""**Rekomendasi film berdasarkan nama aktor**"""

# 1. Menyusun kembali nama aktor menjadi string jika cast_names adalah daftar
final_df['cast_names'] = final_df['cast_names'].apply(lambda x: ' '.join(x) if isinstance(x, list) else x)

# 2. Menggunakan TF-IDF Vectorizer pada kolom cast_names
tfidf_cast = TfidfVectorizer(stop_words='english')
tfidf_cast_matrix = tfidf_cast.fit_transform(final_df['cast_names'])

# 3. Menghitung cosine similarity berdasarkan aktor
cosine_sim_cast = cosine_similarity(tfidf_cast_matrix, tfidf_cast_matrix)

# 4. Membuat fungsi rekomendasi berdasarkan aktor
def recommend_movies_by_cast(cast_name, cosine_sim=cosine_sim_cast):
    # Menemukan semua film yang dibintangi oleh aktor yang dipilih
    mask = final_df['cast_names'].str.contains(cast_name, case=False, na=False)

    if not mask.any():
        return "Aktor tidak ditemukan."

    # Mengambil indeks film yang sesuai
    movie_indices = final_df[mask].index.tolist()

    # Mendapatkan skor kesamaan dari semua film dengan film yang dipilih
    sim_scores = []
    for idx in movie_indices:
        sim_scores.extend(enumerate(cosine_sim[idx]))

    # Mengurutkan film berdasarkan skor kesamaan
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Mengambil 10 film paling mirip
    sim_scores = sim_scores[1:11]  # 1:11 karena 0 adalah film itu sendiri

    # Mendapatkan indeks film yang mirip
    recommended_indices = [i[0] for i in sim_scores]

    # Mengembalikan judul film yang mirip dan nilai cosine similarity-nya
    result_df = pd.DataFrame({
        'title': final_df['title'].iloc[recommended_indices].values,
        'cosine_similarity': [i[1] for i in sim_scores]
    })

    return result_df

# 5. Contoh penggunaan sistem rekomendasi berdasarkan aktor
recommended_movies_cast = recommend_movies_by_cast('Christian Bale')
print(recommended_movies_cast)

"""**Mengidentifikasikan kesamaan nilai berdasarkan nama actor**"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul
cosine_sim_cast = pd.DataFrame(cosine_sim, index=final_df['title'], columns=final_df['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap judul
cosine_sim_cast.sample(5, axis=1).sample(20, axis=0)

"""**Menggabungkan hasil dari credit dan movies dengan ratings**"""

# Gabungkan hasil gabungan dengan ratings_df
final_df = pd.merge(ratings_small_df, final_df, left_on='movieId', right_on='id', how='left')

# Pilih kolom yang relevan dari final_df untuk SVD
final_df = final_df[['userId', 'movieId', 'rating', 'title', 'genre_names', 'cast_names']]

"""**Mengimplementasikan metode rekomendasi berbasis SVD menggunakan pustaka surprise. Setelah melatih model dengan data pelatihan, kode ini mengevaluasi kinerja model menggunakan RMSE sebagai metrik.**"""

from surprise import SVD, Dataset, Reader
from surprise.model_selection import train_test_split
from surprise import accuracy

# Pilih kolom yang dibutuhkan untuk SVD
ratings_for_svd = final_df[['userId', 'movieId', 'rating']]

# Gunakan Reader untuk mengatur skema data
reader = Reader(rating_scale=(0.5, 5.0))

# Konversi data ke dalam format Surprise
data = Dataset.load_from_df(ratings_for_svd, reader)

# Bagi data ke dalam train-test split
trainset, testset = train_test_split(data, test_size=0.25)

# Inisialisasi model SVD
svd_model = SVD()

# Latih model
svd_model.fit(trainset)

# Evaluasi model dengan test set
predictions = svd_model.test(testset)
accuracy.rmse(predictions)

"""**Berfungsi untuk memberikan rekomendasi film kepada pengguna berdasarkan model rekomendasi yang telah dilatih**"""

def get_movie_recommendations(user_id, model, final_df, num_recommendations=10):
    rated_movies = final_df[final_df['userId'] == user_id]['movieId'].tolist()
    all_movie_ids = final_df['movieId'].unique()
    unrated_movies = [movie for movie in all_movie_ids if movie not in rated_movies]

    predictions = []
    for movie_id in unrated_movies:
        predictions.append((movie_id, model.predict(user_id, movie_id).est))

    predictions = sorted(predictions, key=lambda x: x[1], reverse=True)
    recommended_movie_ids = [pred[0] for pred in predictions[:num_recommendations]]

    recommended_movies = final_df[final_df['movieId'].isin(recommended_movie_ids)]['title'].unique()
    return recommended_movies

recommended_movies = get_movie_recommendations(user_id=3, model=svd_model, final_df=final_df)
cleaned_movie_list = [movie for movie in recommended_movies if isinstance(movie, str)]
print(cleaned_movie_list)